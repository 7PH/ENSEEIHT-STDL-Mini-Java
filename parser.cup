package fr.n7.stl.block;

import java_cup.runtime.*;
import fr.n7.stl.block.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.util.*;

// Elements du métamodèle pour la construction de l'arbre abstrait
import fr.n7.stl.block.ast.*;
import fr.n7.stl.block.ast.expression.*;
import fr.n7.stl.block.ast.expression.accessible.*;
import fr.n7.stl.block.ast.expression.allocation.*;
import fr.n7.stl.block.ast.expression.assignable.*;
import fr.n7.stl.block.ast.expression.value.*;
import fr.n7.stl.block.ast.instruction.*;
import fr.n7.stl.block.ast.instruction.declaration.*;
import fr.n7.stl.block.ast.scope.*;
import fr.n7.stl.block.ast.type.*;
import fr.n7.stl.block.ast.Block;
import fr.n7.stl.block.ast.RootBlock;
import fr.n7.stl.block.ast.type.declaration.*;
import fr.n7.stl.tam.ast.impl.*;
import fr.n7.stl.tam.ast.*;
import fr.n7.stl.util.*;

/* Variables partagées dans les actions de l'analyseur syntaxique. */
parser code {:

    protected Lexer lexer;

    public String name;

    public Block block;

    public boolean resolve, checkType;

    public double
        resolveTimeMs,
        checkTypeTimeMs,
        allocateMemoryTimeMs,
        getCodeTimeMs;

    public Fragment fragment;

    public Parser(String _name) {
        this();
        this.name = _name;
    }
:}

/* Initialisation de l'analyseur lexical et des variables partagées. */
init with {:
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    File file = new File(this.name);
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    lexer = new Lexer(f,fis);
:};

/* Expression qui permet de progresser dans l'analyse lexicale. */
scan with {: return lexer.next_token(); :};

/* Terminaux qui seront transmis par l'analyseur lexical. */
terminal 			    UL_Point_Virgule, UL_Virgule, UL_Point, UL_Deux_Points, UL_Point_Interrogation, UL_Point_Exclamation;
terminal				UL_Egal, UL_Double_Plus, UL_Double_Moins, UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe;
terminal 			    UL_Plus, UL_Moins, UL_Moins_Unaire, UL_Asterisque, UL_Oblique, UL_Pour_Cent;
terminal				UL_Esperluette, UL_Double_Barre, UL_Double_Esperluette;
terminal				UL_Parenthese_Ouvrante, UL_Parenthese_Fermante;
terminal				UL_Premier, UL_Second;
terminal				UL_Accolade_Ouvrante, UL_Accolade_Fermante;
terminal				UL_Crochet_Ouvrant, UL_Crochet_Fermant;
terminal				UL_Inferieur, UL_Superieur;
terminal				UL_Inferieur_Egal, UL_Superieur_Egal;
terminal				UL_Double_Egal, UL_Exclamation_Egal;
terminal				UL_Si, UL_Sinon, UL_Tant_Que, UL_Nouveau, UL_Afficher, UL_Retour;
terminal				UL_Definition_Constante, UL_Definition_Type, UL_Enregistrement, UL_Enumeration;
terminal				UL_Type_Booleen, UL_Type_Caractere, UL_Type_Chaine, UL_Type_Entier, UL_Type_Vide;
terminal String		    UL_Identificateur, UL_Chaine, UL_Caractere;
terminal String		    UL_Nombre_Entier, UL_Nul, UL_Vrai, UL_Faux; // Valeur transmise par l'analyseur lexical

/* Non terminaux avec type renvoyé par actions sémantiques (RESULT = ...) */
non terminal Block						Program;
non terminal Block						Bloc;
non terminal List<Instruction>			Instructions;
non terminal Instruction					Instruction;
non terminal Instruction					Declaration;
non terminal List<Expression>			Expressions;
non terminal List<FieldDeclaration>		Champs;
non terminal FieldDeclaration			Champ;
non terminal List<LabelDeclaration>		Etiquettes;
non terminal LabelDeclaration			Etiquette;
non terminal List<ParameterDeclaration>	Parameters;
non terminal Pair<String,PartialType>	Identifiant;
non terminal Type						Type, Atomique;
non terminal Expression 					Expression;
non terminal AssignableExpression		Affectable;

/* Associativité et Priorité relative des opérateurs (du moins prioritaire au plus prioritaire) */
/* Opérateur le moins prioritiaire */
precedence nonassoc UL_Parenthese_Fermante;	// Résolution du conflit décaler/réduire sur conversion de type
precedence right UL_Egal;
precedence nonassoc UL_Point_Interrogation, UL_Deux_Points;
precedence left UL_Double_Barre;
precedence left UL_Double_Esperluette;
precedence nonassoc UL_Double_Egal, UL_Exclamation_Egal;
precedence nonassoc UL_Inferieur, UL_Inferieur_Egal, UL_Superieur, UL_Superieur_Egal;
precedence left UL_Plus, UL_Moins;
precedence left UL_Asterisque, UL_Oblique, UL_Pour_Cent;
precedence right UL_Nouveau;
precedence left UL_Premier, UL_Second;
precedence left UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe, UL_Moins_Unaire, UL_Esperluette, UL_Point_Exclamation;
precedence nonassoc UL_Double_Plus, UL_Double_Moins;
precedence left UL_Crochet_Ouvrant, UL_Point, UL_Parenthese_Ouvrante;
/* Opérateur le plus prioritaire */

/* Règles de grammaire attribuée pour la construction de l'arbre abstrait */
/* Program et Bloc sont des non terminaux */
/* UL_Identificateur est un terminal (Unité lexicale) */
/* bloc est la variable utilisable dans l'action sémantique qui contient la valeur renvoyé par l'analyse du Bloc */
Program ::= UL_Identificateur:nom UL_Accolade_Ouvrante Instructions:instructions UL_Accolade_Fermante
			{:
			    RootBlock inputBlock = new RootBlock(instructions);
                block = inputBlock;

				SymbolTable tds = new SymbolTable();
		        double t1 = System.currentTimeMillis();
		        try {
				    resolve = inputBlock.resolve(tds);
		        } catch (Exception e) {
		            resolve = false;
		        }
		        resolveTimeMs = System.currentTimeMillis() - t1;

                if (resolve) {
                    t1 = System.currentTimeMillis();
                    try {
                        checkType = inputBlock.checkType();
                    } catch (Exception e) {
                        checkType = false;
                    }
                    checkTypeTimeMs = System.currentTimeMillis() - t1;
                } else {
                    checkType = false;
                    checkTypeTimeMs = 0;
                }

                if (resolve && checkType) {
                    t1 = System.currentTimeMillis();
                    inputBlock.allocateMemory(Register.SB, 0);
                    allocateMemoryTimeMs = System.currentTimeMillis() - t1;
                    t1 = System.currentTimeMillis();
                    fragment = inputBlock.getCode(new TAMFactoryImpl());
                    getCodeTimeMs = System.currentTimeMillis() - t1;
                } else {
                    allocateMemoryTimeMs = 0;
                    getCodeTimeMs = 0;
                }
			:}
		;

Bloc ::= UL_Accolade_Ouvrante Instructions:instructions UL_Accolade_Fermante
			{:
				RESULT = null;
			:}
		;