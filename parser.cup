/*
    Grammaire attribuée pour construire l'arbre abstrait correspondant au langage Mini-Java
*/

package fr.n7.stl.block;

import java_cup.runtime.*;
import fr.n7.stl.block.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.util.*;

// Elements du métamodèle pour la construction de l'arbre abstrait
import fr.n7.stl.block.ast.*;
import fr.n7.stl.block.ast.expression.*;
import fr.n7.stl.block.ast.expression.accessible.*;
import fr.n7.stl.block.ast.expression.allocation.*;
import fr.n7.stl.block.ast.expression.assignable.*;
import fr.n7.stl.block.ast.expression.value.*;
import fr.n7.stl.block.ast.instruction.*;
import fr.n7.stl.block.ast.instruction.declaration.*;
import fr.n7.stl.block.ast.scope.*;
import fr.n7.stl.block.ast.type.*;
import fr.n7.stl.block.ast.type.declaration.*;
import fr.n7.stl.tam.ast.impl.*;
import fr.n7.stl.tam.ast.*;
import fr.n7.stl.util.*;

/* Variables partagées dans les actions de l'analyseur syntaxique. */
parser code {:
    protected Lexer lexer;
    public String name;
    //public Block block;
    //public boolean resolve, checkType;
    //public double
    //    resolveTimeMs,
    //    checkTypeTimeMs,
    //    allocateMemoryTimeMs,
    //    getCodeTimeMs;
    //public Fragment fragment;
    public Parser(String name) {
        this();
        this.name = name;
    }
:}

/* Initialisation de l'analyseur lexical et des variables partagées. */
init with {:
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    File file = new File(this.name);
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    lexer = new Lexer(f, fis);
:};

/* Expression qui permet de progresser dans l'analyse lexicale. */
scan with {: return lexer.next_token(); :};

/* Terminaux qui seront transmis par l'analyseur lexical. */
terminal 			    UL_Point_Virgule, UL_Virgule, UL_Point, UL_Deux_Points, UL_Point_Interrogation, UL_Point_Exclamation;
terminal				UL_Egal/*, UL_Double_Plus, UL_Double_Moins, UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe*/;
terminal 			    UL_Plus, UL_Moins/*, UL_Moins_Unaire*/, UL_Asterisque, UL_Oblique, UL_Pour_Cent;
terminal				UL_Esperluette, UL_Double_Barre, UL_Double_Esperluette;
terminal				UL_Parenthese_Ouvrante, UL_Parenthese_Fermante;
//terminal				UL_Premier, UL_Second;
terminal				UL_Accolade_Ouvrante, UL_Accolade_Fermante;
terminal				UL_Crochet_Ouvrant, UL_Crochet_Fermant;
terminal				UL_Inferieur, UL_Superieur;
terminal				UL_Inferieur_Egal, UL_Superieur_Egal;
terminal				UL_Double_Egal, UL_Exclamation_Egal;
terminal				UL_Si, UL_Sinon, UL_Tant_Que, UL_Nouveau, UL_Afficher, UL_Retour;
//terminal				UL_Definition_Constante,  UL_Definition_Type, UL_Enregistrement, UL_Enumeration;
terminal				UL_Type_Booleen, UL_Type_Caractere, UL_Type_Chaine, UL_Type_Entier/*, UL_Type_Flottant*/, UL_Type_Vide;
terminal String		    UL_Identificateur, UL_Chaine, UL_Caractere;
terminal String		    UL_Nombre_Entier/*, UL_Nombre_Flottant*/, UL_Nul, UL_Vrai, UL_Faux; // Valeur transmise par l'analyseur lexical
/* @TODO */
terminal 				UL_Extends, UL_Class, UL_Implements, UL_Interface;
terminal				UL_Public, UL_Private, UL_Final, UL_Static, UL_Abstract;

/* Non terminaux avec type renvoyé par actions sémantiques (RESULT = ...) */
non terminal Block						    Bloc;
non terminal List<Instruction>			    Instructions;
non terminal Instruction					Instruction;
non terminal Instruction					Declaration;
non terminal List<Expression>			    Expressions;
non terminal List<ParameterDeclaration>	    Parameters;
non terminal Pair<String,PartialType>	    Identifiant;
//non terminal Type						    Type, Atomique;
non terminal Expression 					Expression;
non terminal AssignableExpression		    Affectable;
/** @TODO */
non terminal Integer						    Program;
non terminal Integer                           InterfaceDeclaration;
non terminal Integer                           ClassDeclaration;
non terminal Integer                           MethodSignatures;
non terminal Integer                           MethodSignature;
non terminal Integer                           Instantiations;
non terminal Integer                           Instantiation;
non terminal Integer                           NullableType;
non terminal Integer                           ClassModifier;
non terminal Integer                           Extension;
non terminal Integer                           Definitions;
non terminal Integer                           GenericTypes;
non terminal Integer                           GenericType;
non terminal Integer                           GenericInstantiations;
non terminal Integer                           Definition;
non terminal Integer                           AccessModifier;
non terminal Integer                           ClassConstructor;
non terminal Integer                           DefinitionModifier;
non terminal Integer                           AttributeDefinition;
non terminal Integer                           MethodDefinition;
non terminal Integer                           NonArrayType;
non terminal Integer                           Type;


/* Associativité et Priorité relative des opérateurs (du moins prioritaire au plus prioritaire) */
/* Opérateur le moins prioritiaire */
precedence nonassoc         /* @TODO */ UL_Identificateur;
precedence nonassoc         UL_Parenthese_Fermante;	// Résolution du conflit décaler/réduire sur conversion de type
precedence right            UL_Egal;
precedence nonassoc         UL_Point_Interrogation, UL_Deux_Points;
precedence left             UL_Double_Barre;
precedence left             UL_Double_Esperluette;
precedence nonassoc         UL_Double_Egal, UL_Exclamation_Egal;
precedence nonassoc         UL_Inferieur, UL_Inferieur_Egal, UL_Superieur, UL_Superieur_Egal;
precedence left             UL_Plus, UL_Moins;
precedence left             UL_Asterisque, UL_Oblique, UL_Pour_Cent;
precedence right            UL_Nouveau;
precedence left             /*UL_Double_Plus_Prefixe, UL_Double_Moins_Prefixe, UL_Moins_Unaire,*/ UL_Esperluette, UL_Point_Exclamation;
//precedence nonassoc         UL_Double_Plus, UL_Double_Moins;
precedence left             UL_Crochet_Ouvrant, UL_Point, UL_Parenthese_Ouvrante;
/* Opérateur le plus prioritaire */




// Program
//  - ($InterfaceDeclaration|$ClassDeclaration)+
Program ::=
    Program:program InterfaceDeclaration:interfaceDeclaration
        {: RESULT = 1; :}
    | Program:program ClassDeclaration:classDeclaration
        {: RESULT = 1; :}
    | InterfaceDeclaration:interfaceDeclaration
        {: RESULT = 1; :}
    | ClassDeclaration:classDeclaration
        {: RESULT = 1; :};

// InterfaceDeclaration
//  - "interface" $Declaration ("extends" $Instantiations)? "{" $MethodSignatures "}"
InterfaceDeclaration ::=
    UL_Interface Declaration:declaration UL_Crochet_Ouvrant MethodSignatures:signatures UL_Crochet_Fermant
        {: RESULT = 1; :}
    | UL_Interface Declaration:declaration UL_Extends Instantiations:instantiations UL_Crochet_Ouvrant MethodSignatures:signatures UL_Crochet_Fermant
        {: RESULT = 1; :};

// MethodSignatures
//  - ($MethodSignature ";")*
MethodSignatures ::=
    MethodSignature:methodeSignature UL_Point_Virgule MethodSignatures:methodeSignatures
        {: RESULT = 1; :}
    |
        {: RESULT = 1; :};

// MethodSignature
//  - $NullableType $Identificateur "(" $Parameters? ")"
MethodSignature ::=
    NullableType:nullable UL_Identificateur:name UL_Parenthese_Ouvrante UL_Parenthese_Fermante
        {: RESULT = 1; :}
    | NullableType:nullable UL_Identificateur:name UL_Parenthese_Ouvrante Parameters:parameters UL_Parenthese_Fermante
        {: RESULT = 1; :};

// NullableType
//  - (void|$Type)
NullableType ::=
    UL_Type_Vide
        {: RESULT = 1; :}
    | Type:type
        {: RESULT = 1; :};

// Parameters
//  - ($Parameter ",")* $Parameter
//Parameters ::=
//    Parameters:parameters UL_Virgule Parameter:parameter
//        {: RESULT = 1; :}
//    | Parameter:parameter
//        {: RESULT = 1; :};

// Parameter
//  - $Type $UL_Identificateur
//Parameter ::=
//    Type:type UL_Identificateur:ident
//        {: RESULT = 1; :};

// Instantiations (instantiation of generic types)
//  - ($Instantiation ",")* $Instantiation
Instantiations ::=
    Instantiation:instantiation
        {: RESULT = 1; :}
    | Instantiations:instantiations UL_Virgule Instantiation:instantiation
        {: RESULT = 1; :};

// Instantiation
//  - $UL_Identificateur ("<" $Instanciations ">")?
Instantiation ::=
    UL_Identificateur:ident
        {: RESULT = 1; :}
    | UL_Identificateur:ident UL_Inferieur Instantiations:instantiations UL_Superieur
        {: RESULT = 1; :};

// ClassDeclaration
//  - $ClassModifier $Declaration $Extension "{" $Definitions "}"
ClassDeclaration ::=
    ClassModifier:modifier UL_Class Declaration:declaration Extension:extension UL_Crochet_Ouvrant Definitions:definitions UL_Crochet_Fermant
        {: RESULT = 1; :};

// ClassModifier
//  - (final|abstract)?
ClassModifier ::=
    UL_Final
        {: RESULT = 1; :}
    | UL_Abstract
        {: RESULT = 1; :}
    |
        {: RESULT = 1; :};

// Declaration
//  - $UL_Identificateur ("<" GenericTypes ">")?
Declaration ::=
    UL_Identificateur
        {: RESULT = 1; :}
    | UL_Identificateur UL_Inferieur GenericTypes:generics UL_Superieur
        {: RESULT = 1; :};

// GenericTypes
//  - ($GenericType ",")* $GenericType
GenericTypes ::=
    GenericType
        {: RESULT = 1; :}
    | GenericTypes:generics UL_Virgule GenericType:generic
        {: RESULT = 1; :};

// GenericType
//  - $UL_Identificateur ("extends" $GenericInstantiations)?
GenericType ::=
    UL_Identificateur
        {: RESULT = 1; :}
    | UL_Identificateur UL_Extends GenericInstantiations:genericInstantiations
        {: RESULT = 1; :};

// GenericInstantiations
//  - ($Instantiation ",")* $Instantiation
GenericInstantiations ::=
    Instantiation
        {: RESULT = 1; :}
    | GenericInstantiations:genericInstantiations UL_Esperluette Instantiation:instantiation
        {: RESULT = 1; :};

// Extension
//  - ("extends" $Instantiations)? ("implements" $Instantiations)?
Extension ::=
    UL_Extends Instantiation:instantiation
        {: RESULT = 1; :}
    | UL_Extends Instantiation:instantiation UL_Implements Instantiations:instantiations
        {: RESULT = 1; :}
    | UL_Implements Instantiations:instantiations
        {: RESULT = 1; :}
    |
        {: RESULT = 1; :};

// Definitions - methods and attributes definition inside a class
//  - ($Definition)*
Definitions ::=
    Definitions:definitions Definition:definition
        {: RESULT = 1; :}
    |
        {: RESULT = 1; :};

// Definition - definition of one method/attribute
//  ("public"|"private") ($ClassConstructor|($DefinitionModifier ($Attribute|$Method)))
Definition ::=
    AccessModifier:access ClassConstructor:constructor
        {: RESULT = 1; :}
    | AccessModifier:access DefinitionModifier:modifier AttributeDefinition:attributeDefinition
        {: RESULT = 1; :}
    | AccessModifier:access DefinitionModifier:modifier MethodDefinition:methodDefinition
        {: RESULT = 1; :};

// DefinitionModifier
//  - "static"? "final"?
DefinitionModifier ::=
    UL_Static
        {: RESULT = 1; :}
    | UL_Final
        {: RESULT = 1; :}
    | UL_Static UL_Final
        {: RESULT = 1; :}
    |
        {: RESULT = 1; :};

// ClassConstructor
// - $UL_Identificateur "(" $Parameters ")"
ClassConstructor ::=
    UL_Identificateur UL_Parenthese_Ouvrante UL_Parenthese_Fermante Bloc:body
        {: RESULT = 1; :}
    | UL_Identificateur UL_Parenthese_Ouvrante Parameters:parameters UL_Parenthese_Fermante Bloc:body
        {: RESULT = 1; :};

// AccessModifier
//  - (public|private)
AccessModifier ::=
    UL_Public
        {: RESULT = 1; :}
    | UL_Private
        {: RESULT = 1; :};

// AttributeDefinition
//  - $Type $UL_Identificateur ";"
AttributeDefinition ::=
    Type:type UL_Identificateur UL_Point_Virgule
        {: RESULT = 1; :};

// MethodDefinition
//  - "abstract"? $MethodSignature $Bloc
MethodDefinition ::=
    MethodSignature:methodSignature Bloc:body
        {: RESULT = 1; :}
    | UL_Abstract MethodSignature:methodSignature Bloc:body
        {: RESULT = 1; :};

// Type
//  - $NonArrayType ("[]")?
Type ::=
    NonArrayType:type
        {: RESULT = 1; :}
    | NonArrayType:type UL_Crochet_Ouvrant UL_Crochet_Fermant
        {: RESULT = 1; :};

// NonArrayType
//  - (bool|character|String|int|$Instanciation)
NonArrayType ::=
    UL_Type_Entier
        {: RESULT = 1; :}
    | UL_Type_Booleen
        {: RESULT = 1; :}
    | UL_Type_Caractere
        {: RESULT = 1; :}
    | UL_Type_Chaine
        {: RESULT = 1; :}
    | Instantiation:instantiation
        {: RESULT = 1; :};

// Bloc
//  - "{" $Instructions* "}"
Bloc ::=
    UL_Accolade_Ouvrante Instructions:instructions UL_Accolade_Fermante
        {: /* RESULT = new Block(instructions); */ :};



/*
Atomique ::= UL_Type_Booleen
			{:
				RESULT = AtomicType.BooleanType;
			:}
		|	UL_Type_Caractere
			{:
				RESULT = AtomicType.CharacterType;
			:}
		|	UL_Type_Chaine
			{:
				RESULT = AtomicType.StringType;
			:}
		|	UL_Type_Entier
			{:
				RESULT = AtomicType.IntegerType;
			:}
		;

Type ::= Atomique:atomique
			{:
				RESULT = atomique;
			:}
		| UL_Identificateur:nom
			{:
				RESULT = new NamedType(nom);
			:}
		;
*/

Instructions ::= Instructions:instructions Instruction:instruction
				{:
					instructions.add(instruction);
					RESULT = instructions;
				:}
			|
				{: RESULT = new LinkedList<Instruction>(); :}
			;

Parameters ::= Parameters:parameters UL_Virgule Type:type UL_Identificateur:identifiant
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					parameters.add( new ParameterDeclaration( identifiant.getLeft(), _type) );
					RESULT = parameters;
				:}
			| Type:type Identifiant:identifiant
				{:
					List<ParameterDeclaration> _parameters = new LinkedList<ParameterDeclaration>();
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					_parameters.add( new ParameterDeclaration( identifiant.getLeft(), _type) );
					RESULT = _parameters;
				:}
			;

Declaration ::= Type:type Identifiant:identifiant UL_Egal Expression:valeur UL_Point_Virgule
				{:
					Type _type = identifiant.getRight();
					if (_type == null) {
						_type = type;
					} else {
						_type = ((PartialType)_type).complete( type );
 					}
					RESULT = new VariableDeclaration( identifiant.getLeft(), _type, valeur);
				:}
			;

Instruction ::= Declaration:declaration
				{:
					RESULT = declaration;
				:}
			| Affectable:affectable UL_Egal Expression:expression UL_Point_Virgule
				{:
					RESULT = new Assignment( affectable, expression);
				:}
			| UL_Identificateur:nom UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante  UL_Point_Virgule
             	{:
					RESULT = new FunctionCall( nom, parametres );
				:}
			| UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante  UL_Point_Virgule
             	{:
					List<Expression> _parametres = new LinkedList<Expression>();
					RESULT = new FunctionCall( nom, _parametres );
				:}
			| UL_Afficher Expression:expression UL_Point_Virgule
				{:
					RESULT = new Printer( expression );
				:}
			| UL_Si UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:alors UL_Sinon Bloc:sinon
				{:
					RESULT = new Conditional( condition, alors, sinon);
				:}
			| UL_Si UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:alors
				{:
					RESULT = new Conditional( condition, alors);
				:}
			| UL_Tant_Que UL_Parenthese_Ouvrante Expression:condition UL_Parenthese_Fermante Bloc:corps
				{:
					RESULT = new Iteration( condition, corps);
				:}
			| UL_Retour Expression:expression UL_Point_Virgule
				{:
					RESULT = new Return( expression);
				:}
			;

Expressions ::= Expressions:expressions UL_Virgule Expression:expression
				{:
					expressions.add( expression );
					RESULT = expressions;
				:}
            | Expression:expression
            		{:
					List<Expression> _expressions = new LinkedList<Expression>();
					_expressions.add( expression );
					RESULT = _expressions;
				:}
            ;

Affectable ::= UL_Identificateur:nom
				{:
					RESULT = new VariableAssignment( nom );
				:}
			| Affectable:tableau UL_Crochet_Ouvrant Expression:indice UL_Crochet_Fermant
				{:
					RESULT = new ArrayAssignment( tableau, indice);
				:}
			| UL_Parenthese_Ouvrante Affectable:affectable UL_Parenthese_Fermante
				{:
					RESULT = affectable;
				:}
			| Affectable:enregistrement UL_Point UL_Identificateur:etiquette
				{:
					RESULT = new FieldAssignment( enregistrement, etiquette);
				:}
			| Affectable:enregistrement UL_Point UL_Identificateur:etiquette UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
				{:
					// TODO
				:}
			| Affectable:enregistrement UL_Point UL_Identificateur:etiquette UL_Parenthese_Ouvrante UL_Parenthese_Fermante
				{:
					// TODO
				:}
			| UL_Identificateur:nom UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
             	{:
					// TODO
				:}
			| UL_Identificateur:nom UL_Parenthese_Ouvrante UL_Parenthese_Fermante
             	{:
					// TODO
				:}
			;

Expression ::= /* Affectable:affectable UL_Egal Expression:expression
				{:
					RESULT = new Assignment( affectable, expression);
				:}
			| */ Expression:gauche UL_Double_Egal Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Equals, droite);
				:}
			| Expression:gauche UL_Exclamation_Egal Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Different, droite);
				:}
			| Expression:gauche UL_Inferieur Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Lesser, droite);
				:}
			| Expression:gauche UL_Superieur Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Greater, droite);
				:}
			| Expression:gauche UL_Inferieur_Egal Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.LesserOrEqual, droite);
				:}
			| Expression:gauche UL_Superieur_Egal Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.GreaterOrEqual, droite);
				:}
			| Expression:gauche UL_Double_Barre Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Or, droite);
				:}
            | Expression:gauche UL_Double_Esperluette Expression:droite
             	{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.And, droite);
				:}
			| Expression:gauche UL_Plus Expression:droite
				{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Add, droite);
				:}
            | Expression:gauche UL_Moins Expression:droite
             	{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Substract, droite);
				:}
            | Expression:gauche UL_Asterisque Expression:droite
             	{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Multiply, droite);
				:}
			| Expression:gauche UL_Oblique Expression:droite
             	{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Divide, droite);
				:}
			| Expression:gauche UL_Pour_Cent Expression:droite
             	{:
					RESULT = new BinaryExpression( gauche, BinaryOperator.Modulo, droite);
				:}
            | UL_Moins Expression:expression
             	{:
					RESULT = new UnaryExpression( UnaryOperator.Opposite, expression);
				:}
            | UL_Point_Exclamation Expression:expression
             	{:
					RESULT = new UnaryExpression( UnaryOperator.Negate, expression);
				:}
			| Expression:expression UL_Crochet_Ouvrant Expression:indice UL_Crochet_Fermant
				{:
					RESULT = new ArrayAccess( expression, indice );
				:}
			| Expression:expression UL_Point UL_Identificateur:etiquette
				{:
					RESULT = new FieldAccess( expression, etiquette );
				:}
			| Expression:expression UL_Point UL_Identificateur:etiquette UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
				{:
					// TODO
				:}
			| Expression:expression UL_Point UL_Identificateur:etiquette UL_Parenthese_Ouvrante UL_Parenthese_Fermante
				{:
					// TODO
				:}
			| Expression:condition UL_Point_Interrogation Expression:alors UL_Deux_Points Expression:sinon
				{:
					RESULT = new ConditionalExpression( condition, alors, sinon);
				:}
			| UL_Parenthese_Ouvrante Expression:expression UL_Parenthese_Fermante
             	{:
					RESULT = expression;
				:}
			| UL_Parenthese_Ouvrante UL_Identificateur:type UL_Parenthese_Fermante Expression:expression
             	{:
					RESULT = new TypeConversion( expression, type);
				:}
			| UL_Accolade_Ouvrante Expressions:expressions UL_Accolade_Fermante
             	{:
					RESULT = new Sequence( expressions );
				:}
			| UL_Identificateur:nom
             	{:
					RESULT = new IdentifierAccess( nom );
				:}
			| // TODO : Should accept an expression as function
				UL_Identificateur:nom	UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
             	{:
					RESULT = new FunctionCall( nom, parametres );
				:}
			| // TODO : Should accept an expression as function
				UL_Identificateur:nom	UL_Parenthese_Ouvrante UL_Parenthese_Fermante
             	{:
					List<Expression> _parametres = new LinkedList<Expression>();
					RESULT = new FunctionCall( nom, _parametres );
				:}
			| UL_Nombre_Entier:entier
             	{:
					RESULT = new IntegerValue( entier );
				:}
			| UL_Vrai
             	{:
					RESULT = BooleanValue.True;
				:}
			| UL_Faux
             	{:
					RESULT = BooleanValue.False;
				:}
			| UL_Nul
             	{:
					RESULT = NullValue.Null;
				:}
			| UL_Caractere:caractere
             	{:
					RESULT = new CharacterValue( caractere );
				:}
			| UL_Chaine:chaine
             	{:
					RESULT = new StringValue( chaine );
				:}
			| UL_Nouveau Type:type UL_Crochet_Ouvrant Expression:taille UL_Crochet_Fermant
             	{:
					RESULT = new ArrayAllocation( type, taille );
				:}
			| UL_Nouveau Type:type UL_Parenthese_Ouvrante UL_Parenthese_Fermante
             	{:
					RESULT = new PointerAllocation( type );
				:}
			| UL_Nouveau Type:type UL_Parenthese_Ouvrante Expressions:parametres UL_Parenthese_Fermante
             	{: /* TODO */ :}
            ;
       